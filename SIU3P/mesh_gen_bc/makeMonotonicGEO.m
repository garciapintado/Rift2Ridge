function GEO = makeMonotonicGEO(GEO, tolerance)
    % +++ purpose +++
    % This function forces x-monotonicity for quasi-horizontal GEO interfaces
    % No nodes are added or removed from GEO. Only horizontal displacements are made.
    %
    % GEO:  IO. Struct, in which each (i) element represents a polyline with (at least) components 
    %    (i).coo        :: REAL [2,ni]    x,z coordinates defining domain and subdomain boundaries
    %    (i).gid        :: INTEGER, polyline identifier
    %   
    % Author: Javier Garc√≠a-Pintado, MARUM, 2020-08
    % Last update:                          2022-03 - replace update links by direct cooordinate search in collapsed interfaces
    
    %if nargin < 3
    %    update_links = true;
    %end
    
    
    GEO = findJunctionsGEO(GEO); % hold on; plot(GEO(6).coo(1,GEO(6).junctions)/1000, GEO(6).coo(2,GEO(6).junctions)/1000, 'o','markersize',10)
    for i=1:length(GEO)
        if ~GEO(i).horizontal
            continue
        end
        l2r = diff(GEO(i).coo(1,[1,end])) > 0. ;
        if ~l2r
            error("makeMonotonicGEO: non left to right GEO horizontal interface at GEO("+i+")")
        end
        diffx = diff(GEO(i).coo(1,:));
        backids = find(diffx <= 0.);                                       % non x-motonony at backids--(backids+1) segments

        if ~isempty(backids)                                               % diffx(backids) % hold on; plot(GEO(i).coo(1,backids)/1000,GEO(i).coo(2,backids)/1000,'s','markersize',15)
            for ib=1:length(backids)
                done = false;
                if ~ismember(backids(ib),GEO(i).junctions)     % try to move single node backwards [in no-joint transect]        
                    % try backward chain-reaction nudging [in no-joint transect]  
                    j = backids(ib) + 1;                               % j could be a junction, but it is not going to be moved
                    di = (1:GEO(i).n) - j;                             % relative index with respect to j 
                    dx = GEO(i).coo(1,:) - GEO(i).coo(1,j);            % relative x-coordinate with respect to GEO(i).coo(1,j)
                    dxdiOK = dx < di .* tolerance & di < 0;            % LOGICAL: true for potentially movable nodes who fulfill the tolerance condition
                    js = (j-1):-1:(find(dxdiOK,1,'last')+1);           % indices of nodes to be moved
                    if ~any(ismember(js,GEO(i).junctions))             % [di(:) dx(:) dxdiOK(:)] happy to move
                        GEO(i).coo(1,js) = GEO(i).coo(1,j) + tolerance * di(js); 
                        done = true;
                    end
                end
                
                if ~done % try forward chain [in -joint transect] note: backids(ib) is possibly a junction now, but correction is over any transect    
                    j = backids(ib);                                   % j is the starting point of a backward segment
                    di = (1:GEO(i).n) - j;                             % relative index with respect to j | di(j) = 0 
                    dx = GEO(i).coo(1,:) - GEO(i).coo(1,j);            % relative x-coordinate with respect to GEO(i).coo(1,j) | dx(j) == 0
                    dxdiOK = dx > di .* tolerance & di > 0;            % LOGICAL: false for nodes who do not fulfill the tolerance condition.
                    js = (j+1):(find(dxdiOK,1)-1);                     % indices of nodes to be moved
                    coob = GEO(i).coo(:,js);                           % background coordinates
                    %if ~any(ismember(js,GEO(i).junctions))            % [di(:) dx(:) dxdiOK(:)]
                    GEO(i).coo(1,js) = GEO(i).coo(1,j) + tolerance * di(js); 
                    cooa = GEO(i).coo(:,js); 
                    done = true;
                    %end
                    for k=1:length(GEO)
                        if k == j
                            continue
                        end
                        [cooink,kids] = ismember(coob', GEO(k).coo','rows'); 
                        if ~any(cooink)
                          continue;
                        end
                        kids = kids(cooink);
                        GEO(k).coo(:,kids) = cooa(:,cooink);
                    end
                end
      
                if ~done  % TODO: make it possible to apply [safe] corrections beyond junctions [would require GEO.to organized as indicated below]
                    error("makeMonotonicGEO: not enough space for chain-reaction nudging in joint-free transect at GEO("+i+").coo(:,"+backids(ib)+")");  
                end
                % WARNING: 
                % GEO.to is generated by getGEOn() or linkGEO() and
                % consumed by generate_meshGEO() and makeMonotonicGEO()
                % as it is now, it points to the highest interface of a
                % clipped GEO node. It is adequatelly consumed by
                % generate_meshGEO() but wrongly consumed here:
                % the following won't work if uplink
                % goes beyond one level (e.g. 3 -> 9).
                % It would be better to rewrite the GEO.to generator, and consumers so that GEO.to just point to the next in order
                % interface, so the following iteration could be safely
                % applied. A similar approach should be used by
                % generate_meshGEO()
                
                
                %if update_links
                %    for j=js
                %        uplink = GEO(i).to(:,j);
                %        while uplink(2) ~= 0
                %            if (uplink(2) - i) ~= 3
                %                error("rewrite getGEO() & linkGEO() so that the current iterative uplink is safe") 
                %            end
                %            GEO(uplink(2)).coo(1,uplink(1)) = GEO(i).coo(1,j); % WARNING: this uplinks to upper levels can potentially lead to non-monotony in higher levels
                %            uplink = GEO(uplink(2)).to(:,uplink(1));
                %        end
                %    end % for j=js
                %end % if update_links 
            
            end % ib=1:length(backids)
        end % if any(backids)
    end % for i=1:length(GEO)
end % function
